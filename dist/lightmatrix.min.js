!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):t.lightmatrix=r()}(this,function(){"use strict";const t=t=>"number"==typeof t&&!isNaN(t),r=t=>0===t?0:t,e=r=>{if(!(r instanceof Array)||0===r.length)return!1;let e;const[...i]=r;for(;i.length>0;){const r=i.shift();if(!(r instanceof Array))return!1;const o=r.length===(e=e||r.length),s=r.filter(r=>(n=r,t(+((n instanceof Object||n)+"")))).length===e;if(!o||!s)return!1}return!0};var n;const i=(t,e,n)=>{const i=[];for(let o=0;t.length>o;o+=1)if(o!==e){const e=[];for(let i=0;t[0].length>i;i+=1)i!==n&&e.push(r(t[o][i]));i.push(e)}return i},o=(t,e)=>{const[...n]=e,i=[e.length,e[0].length];for(let o=0;i[0]>o;o+=1)for(let s=0;i[1]>s;s+=1)n[o][s]=r(e[o][s]*t);return n};var s={ok:e,dimension(t){if(this.ok(t))return[t.length,t[0].length];throw Error("Invalid matrix specification.")},unit(t){const r=t>=1&&t||2,e=[];for(let t=0;r>t;t+=1){e[t]=[];for(let n=0;r>n;n+=1)e[t][n]=t===n?1:0}return e},equal(t,r){const e=this.dimension(t),n=this.dimension(r);if(e[0]!==n[0]||e[1]!==n[1])return!1;for(let n=0;e[0]>n;n+=1)for(let i=0;e[1]>i;i+=1)if(t[n][i]!==r[n][i])return!1;return!0},sum:(t,n)=>{if(!e(t)||!e(n))throw Error("Invalid matrix specification.");const i=[],o=[t.length,t[0].length],s=[n.length,n[0].length];if(o[0]!==s[0]||o[1]!==s[1])throw Error("Matrices not compatible.");for(let e=0;o[0]>e;e+=1){i[e]=[];for(let s=0;o[1]>s;s+=1)i[e][s]=r(t[e][s]+n[e][s])}return i},product:(n,i)=>{if(t(n)){if(t(i))return n*i;if(e(i))return o(n,i)}else if(e(n)){if(t(i))return o(i,n);if(e(i))return((t,e)=>{const n=[t.length,t[0].length],i=[e.length,e[0].length],o=[];if(n[1]===i[0]){for(let s=0;n[0]>s;s+=1){o[s]=[];for(let f=0;i[1]>f;f+=1){let i=0;for(let r=0;n[1]>r;r+=1)i+=t[s][r]*e[r][f];o[s][f]=r(i)}}return o}throw Error("Matrices not compatible.")})(n,i)}throw Error("Invalid arguments supplied.")},transpose(t){const e=this.dimension(t).reverse(),n=[];for(let i=0;e[0]>i;i+=1){n[i]=[];for(let o=0;e[1]>o;o+=1)n[i][o]=r(t[o][i])}return n},determinant(t){let r;const e=this.dimension(t);if(e[0]!==e[1])throw Error("Square matrix required.");if(1===e[0])return t[0][0];for(let e=0;t[0].length>e;e+=1)r=r||0,r+=(0==(1&e)?1:-1)*t[0][e]*this.determinant(i(t,0,e));return r},minors(t){const e=this.dimension(t),n=[];if(e[0]!==e[1])throw Error("Square matrix required.");for(let o=0;e[0]>o;o+=1){n[o]=[];for(let s=0;e[0]>s;s+=1)n[o][s]=r(this.determinant(i(t,o,s)))}return n},cofactors(t){const e=this.dimension(t),n=this.minors(t);for(let t=0;e[0]>t;t+=1)for(let i=0;e[0]>i;i+=1)n[t][i]=r(n[t][i]*(0==(t+i&1)?1:-1));return n},adjoint(t){return this.transpose(this.cofactors(t))},inverse(t){const r=this.determinant(t);if(0===r)throw Error("Cannot compute inverse of singular matrix.");return this.product((t=>1/t)(r),this.adjoint(t))}};const f=t=>s[t].bind(s);return{ok:f("ok"),valid:f("ok"),order:f("dimension"),dimension:f("dimension"),unit:f("unit"),identity:f("unit"),equal:f("equal"),same:f("equal"),sum:f("sum"),add:f("sum"),product:f("product"),multiply:f("product"),transpose:f("transpose"),determinant:f("determinant"),minors:f("minors"),cofactors:f("cofactors"),adjoint:f("adjoint"),inverse:f("inverse")}});
